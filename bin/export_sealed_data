#!/usr/bin/env ruby

require_relative "../search-engine/lib/card_database"

class ExportSealedData
  def initialize
    @db = CardDatabase.load
    @factory = PackFactory.new(@db)
  end

  def flatten_pack(pack)
    if pack.is_a?(WeightedPack)
      pack.flatten_weighted_pack
    else
      WeightedPack.new(pack => 1)
    end
  end

  def extract_sheets(pack)
    sheets = pack.packs.keys.map(&:sheets).flat_map(&:keys)
    sheet_names = {}
    sheets.each do |sheet|
      sheet_names[sheet] ||= "sheet-#{sheet_names.size+1}"
    end
    sheet_names
  end

  def serialize_subpack(pack, weight, sheets)
    {
      sheets: pack.sheets.map{|s,c| [sheets[s], c]}.to_h,
      weight: weight,
    }
  end

  def serialize_sheet(sheet)
    ev = sheet.probabilities
    # Normalize rationals to weights
    lcm = ev.values.map(&:denominator).inject(&:lcm)
    ev = ev.map{|k,v| vv = v*lcm; raise unless vv.to_i == vv; [k, vv.to_i] }.to_h

    cards = ev.map do |e,w|
      {
        card: "#{e.set_code}:#{e.number}",
        foil: e.foil ? true : nil,
        weight: w,
      }.compact
    end

    {
      partner: sheet.is_a?(PartnerCardSheet) ? true : nil,
      balance_colors: sheet.is_a?(ColorBalancedCardSheet) ? true : nil,
      cards: cards,
    }.compact
  end

  def serialize_sheets(sheets)
    sheets.map{|sheet, id|
      [id, serialize_sheet(sheet)]
    }.to_h
  end

  def call(output_path)
    exported_data = []
    @db.sets_with_packs.each do |set|
      pack = @factory.for(set.code)
      pack = flatten_pack(pack)
      sheets = extract_sheets(pack)
      exported_data << {
        name: set.name,
        code: set.code,
        boosters: pack.packs.map{|subpack, weight| serialize_subpack(subpack, weight, sheets) },
        sheets: serialize_sheets(sheets),
      }
    end
    open(output_path, "w") do |fh|
      fh.puts JSON.pretty_generate(exported_data)
    end
  end
end

output_path = ARGV[0] || "export_sealed.json"
ExportSealedData.new.call(output_path)
